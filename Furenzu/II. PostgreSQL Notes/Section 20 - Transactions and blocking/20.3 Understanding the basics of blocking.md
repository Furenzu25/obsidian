## ğŸ§  **Study Notes: PostgreSQL Transactions & Locks (MVCC & Blocking)**

### ğŸ‘‹ Hello students!

Welcome to another engaging class â€” today weâ€™re diving into the fundamentals of **blocking** in PostgreSQL.

---

### ğŸ”„ **Quick Recap: Transactions**

- PostgreSQL allows multiple users to **read data at the same time** without blocking each other â€” this is efficient and safe.
    
- Problems arise when **reads and writes** happen **simultaneously**, which can lead to **conflicts** or inconsistent views of the data.
    

---

### ğŸ” **PostgreSQL's Solution: MVCC**

- **MVCC** stands for **Multi-Version Concurrency Control**.
    
- This system allows:
    
    - Transactions to **see only committed data**.
        
    - A transaction to **not view** changes from another **uncommitted transaction**.
        
- This ensures data **consistency and isolation**, even during concurrent operations.
    
- MVCC is **not supported by all databases**, but PostgreSQL handles it well.
    

---

### ğŸ§ª **Example: Simple Update Case**

- Imagine a table with a single row where `id = 0`.
    
- Two transactions begin:
    
    - **Transaction 1** updates `id = 1`.
        
    - **Transaction 2** reads the same row â†’ still sees `id = 0`.
        
- Even after Transaction 1 commits, Transaction 2 **still sees the original value** because its read snapshot was taken earlier.
    

âœ… This shows MVCC in action: **each transaction gets a consistent snapshot**.

---

### ğŸ’¥ **Write Conflict Scenario**

Suppose you're counting visits to a website:

- Two transactions start at the same time and increment the same value:
    
    - Transaction 1: adds 1
        
    - Transaction 2: adds 1
        
- PostgreSQL ensures that **one waits for the other** to finish and commit, avoiding data loss.
    

â¡ï¸ This allows **thousands of concurrent writes** safely, as long as they donâ€™t collide on the same exact row or key.

---

### ğŸš« **Problem: Duplicate Key Insertion**

Letâ€™s say two users try to insert the same `id = 18` at the same time:

- Both SELECT â†’ see the value is available
    
- Both try to INSERT â†’ **only one succeeds**, the other gets a **duplicate key violation**
    

This is where **explicit locking** becomes crucial.

---

### ğŸ” **Locking in PostgreSQL**

PostgreSQL provides **8 levels of lock modes**, from **light to heavy**:

|Lock Type|Conflict Level|
|---|---|
|`ACCESS SHARE`|Lightest (minimal block)|
|`ACCESS EXCLUSIVE`|Heaviest (full block)|

ğŸ§± Use cases:

- Use **lighter locks** like `ACCESS SHARE` for general reads
    
- **Avoid** using `ACCESS EXCLUSIVE` unless absolutely necessary (it blocks all reads/writes)
    

You can see a detailed lock conflict chart on PostgreSQLâ€™s official documentation to understand **which locks conflict with others**.

---

### ğŸ› ï¸ **LOCK Syntax Example**
	
	sql
	
`BEGIN; LOCK TABLE product IN ACCESS EXCLUSIVE MODE; INSERT INTO product VALUES (...); COMMIT;`

This guarantees full control over the table, but **prevents anyone else from reading or writing** until the lock is released.

---

### ğŸ’¡ **Better Practice: Row-Level Locking**

To avoid full table locks, you can lock **just one row** using a watermark strategy:

#### Example:

1. Create a watermark table with a single row (used as a counter)
    
2. Lock and update this row to generate **unique sequential numbers** (e.g., invoice numbers)
    

âœ… **Only one transaction at a time** can update the watermark row  
âœ… No other operations on other rows or tables are blocked

---

### ğŸ¯ **Key Takeaways**

- PostgreSQL uses **MVCC** to isolate transactions and keep reads consistent.
    
- **Writes can conflict**, so use locking mechanisms to maintain data integrity.
    
- Use the **right lock level**:
    
    - Light for concurrent reads
        
    - Strong only when needed
        
- Implement **row-level locking strategies** to avoid full-table blocks
    
- Always **commit** your transactions to make changes visible to others
    

---

### ğŸ“š Bonus Material

Check out the MVCC article on [Wikipedia](https://en.wikipedia.org/wiki/Multiversion_concurrency_control) and PostgreSQLâ€™s [Locking Documentation](https://www.postgresql.org/docs/current/explicit-locking.html) for deeper reading.

---

### âœ… Next Steps

We'll continue to explore:

- More use cases for locks
    
- Deeper examples with real-world scenarios
    
- Optimizing concurrent behavior in PostgreSQL
    

---

### ğŸ¤— Thatâ€™s it for today!

Thanks for following along. Keep experimenting with transactions and locks.  
**See you in the next class!**  
ğŸ‘‹ Hugs to everyone!