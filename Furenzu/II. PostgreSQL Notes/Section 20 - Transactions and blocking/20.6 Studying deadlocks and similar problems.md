# ğŸ”’ Study Notes: Understanding Deadlocks in Databases

## ğŸ‘‹ Hello Students!

Today weâ€™re diving into a **critical topic in database systems** â€” **Deadlocks**. These are common and can happen in any database engine. Letâ€™s break it down and understand how they occur, how to recognize them, and what to do when they happen.

---

## âš ï¸ What is a Deadlock?

A **deadlock** is a conflict that occurs when **two or more transactions are waiting on each other indefinitely**.

### ğŸ§© Example Scenario:

Imagine we have:

- ğŸ§¾ **Transaction 1** trying to update `row A`.
    
- ğŸ§¾ **Transaction 2** trying to update `row B`.
    

Now:

- Transaction 1 wants to also update `row B` (which is locked by Transaction 2).
    
- Transaction 2 wants to update `row A` (which is locked by Transaction 1).
    

ğŸš« Neither transaction can proceed because theyâ€™re waiting for the other to release its lock.

---

## ğŸ” How It Unfolds in PostgreSQL
	
	sql
	
`-- Transaction 1 BEGIN; UPDATE table SET id = id * 10 WHERE id = 1;  -- Transaction 2 BEGIN; UPDATE table SET id = id * 10 WHERE id = 2;`

Now both transactions try to update **each otherâ€™s rows**, causing a **deadlock**.

### ğŸ’£ Result:

- PostgreSQL **detects the deadlock**.
    
- It **automatically resolves it** by **rolling back one of the transactions**.
    
- Example:
    
    - âŒ Transaction 2 gets a `ROLLBACK`.
        
    - âœ… Transaction 1 proceeds and **commits**.
        

---

## ğŸ› ï¸ PostgreSQL Helps You Detect the Issue

- When a deadlock happens, PostgreSQL shows:
    
    - **Which query** caused the issue.
        
    - **Where** in the process it occurred.
        
    - The **row** or **physical location** involved.
        

You can run:
	
	sql
	
`SELECT * FROM deadlock WHERE id = 3.0.3;`

ğŸ” This allows you to investigate â€” but remember, if the row was deleted or modified, it may not be returned.

---

## ğŸ§ª Deadlocks in Action (Another Scenario)

Let's say:
	
	sql
	
`-- Transaction 1 BEGIN ISOLATION LEVEL ...; SELECT * FROM table; -- returns 2 rows  -- Transaction 2 BEGIN; DELETE FROM table; -- tries to delete those 2 rows`

Even though reading is fine, the problem begins when:

- Transaction 2 tries to **delete** data thatâ€™s still being **read** or held by Transaction 1.
    

### ğŸ’¥ What Happens:

- PostgreSQL **fails** the transaction due to conflict.
    
- â— `ROLLBACK` occurs on one transaction.
    

---

## ğŸ§‘â€ğŸ’» Practical Implications

- These issues are **common in real-world applications**.
    
- If not handled properly, they cause **failed transactions** and **poor user experience**.
    
- Applications must be prepared to handle:
    
    - ğŸŒ€ **Automatic rollbacks**
        
    - ğŸ” **Retry logic**
        
    - ğŸ“‰ **Transaction failures**
        

---

## âœ… Key Takeaways

- ğŸ”„ **Deadlocks happen when two transactions wait on each other**.
    
- ğŸ§  PostgreSQL detects and resolves them automatically (by rolling one back).
    
- ğŸ“Š Theyâ€™re more likely to occur with **update/delete** operations, not just `SELECT`.
    
- ğŸ§° Always design your applications to **handle unexpected rollbacks** gracefully.
    
- ğŸ§ PostgreSQL provides detailed error logs and physical row references to help debug.
    

---

## ğŸ¤ That's It!

Now you understand:

- What deadlocks are
    
- How they occur
    
- How PostgreSQL handles them
    
- How to prepare your apps to recover from them
    

ğŸ“š Keep practicing, and be ready to write better, safer transaction logic!  
ğŸ‘ Great job and see you in the next lesson!