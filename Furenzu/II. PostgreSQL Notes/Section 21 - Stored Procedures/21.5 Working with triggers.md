# ğŸ“š PostgreSQL Study Notes â€“ Triggers & Stored Procedures

---

## ğŸš€ Introduction to Triggers

A **trigger** in PostgreSQL is a mechanism that allows you to automatically execute a function in response to certain events on a table or view.

### ğŸ“Œ Key Concepts:

- **Trigger** = automatic action on INSERT, UPDATE, DELETE, or TRUNCATE.
    
- Triggers are useful for:
    
    - Validating or modifying inserted data
        
    - Logging operations
        
    - Executing side-effects like updates to other tables
        

### ğŸ§  Syntax Overview:
	
	sql
	
`CREATE TRIGGER trigger_name { BEFORE | AFTER | INSTEAD OF } { INSERT | UPDATE | DELETE | TRUNCATE } ON table_name FOR EACH ROW EXECUTE FUNCTION function_name();`

- `BEFORE`: Executes before the operation
    
- `AFTER`: Executes after the operation
    
- `INSTEAD OF`: Replaces the operation (mostly used for views)
    
- Triggers are executed **in alphabetical order** if multiple exist
    

---

## ğŸ”¥ Example: Trigger to Normalize Data

### ğŸ¯ Goal: Convert any inserted temperature of `-273` to `0`.

**Step-by-step**:

1. Create a table `sensor_data` with fields `id`, `timestamp`, and `temperature`.
    
2. Define a function using `NEW.temperature`:
		
		sql
		
    `IF NEW.temperature = -273 THEN     NEW.temperature := 0; END IF;`
    
3. Attach the function to a trigger that fires **BEFORE INSERT**.
    

ğŸ§ª Test Results:

- Insert `-300` â†’ Temperature becomes `0`.
    
- Insert `-100` â†’ No change, as it's not in the condition.
    

âœ… Triggers successfully intercept and modify values before they're stored.

---

## ğŸ§¾ Example: Trigger Summary Output

PostgreSQL allows logging internal trigger metadata such as:

- ğŸ”– Trigger name
    
- ğŸ—ƒ Schema
    
- ğŸ§¾ Table
    
- ğŸ•’ When it was triggered (BEFORE/AFTER)
    
- ğŸ“¤ Operation type (INSERT, UPDATE, DELETE)
    

This can be useful for **auditing** or **debugging** complex workflows.

---

## ğŸ“š Advanced: Transition Tables

Since **PostgreSQL 10**, you can use **transition tables** to handle **multiple row changes at once**.

### ğŸ›  Use case:

- Track **batch INSERTS/DELETES**
    
- Transition tables give access to **all rows affected** during the operation.
    

### ğŸ”„ Example:

- Insert 5 rows using a loop
    
- Access all new rows via the transition table in the trigger function
    
- Works similarly for DELETE
    

âš ï¸ **Caution**: Transition tables are **memory-heavy**. Avoid for **billions of rows** or in **high-concurrency** systems.

---

## ğŸ“¦ Stored Procedures

A **stored procedure** is like a function, but it allows:

- Explicit transaction control (e.g., COMMIT/ROLLBACK)
    
- Batch processing
    
- More complex workflows than simple triggers
    

### ğŸ§ª Example:
	
	sql
	
`CREATE PROCEDURE example_procedure() LANGUAGE plpgsql AS $$ BEGIN     CREATE TABLE a (id INTEGER);     CREATE TABLE b (id INTEGER);     -- Simulate rollback for table c END; $$;`

To run it:
	
	sql
	
`CALL example_procedure();`

ğŸ“Œ Observations:

- Tables A and B will be created
    
- Table C (with rollback logic) may not be persisted
    
- Useful for **automating complex operations** like migrations or setup scripts
    

---

## ğŸ›‘ Final Tips & Best Practices

- âš ï¸ **Avoid excessive trigger logic** if your app has:
    
    - High user traffic
        
    - Multiple threads/connections
        
- ğŸ“ˆ Monitor **performance impact**
    
- ğŸ§° Use triggers for **automation**, but prefer **procedures** for **multi-step business logic**
    
- ğŸ“– Always consult the **official PostgreSQL docs** for syntax and advanced features
    

---

ğŸ‰ **Thatâ€™s it!** Youâ€™ve now covered:

- âœ… Basic to advanced use of Triggers
    
- âœ… Trigger metadata logging
    
- âœ… Transition tables for batch operations
    
- âœ… Stored procedures with explicit transactions
    

Stay curious, keep experimenting, and happy coding with PostgreSQL! ğŸ˜ğŸ’»